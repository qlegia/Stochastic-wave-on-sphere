#!/bin/bash
import matplotlib as mpl
mpl.use('Agg')
import matplotlib.pyplot as plt
import numpy as np
# the Mittag-Leffler function package https://github.com/khinsen/mittag-leffler
#from mittag_leffler import ml
# import the stochastic integral package
#import sdeint  #  https://pypi.org/project/sdeint/
from MLF import Eab,Eabder
import scipy.integrate as integrate
import scipy.io as sio
import sys
import healpy as hp
from colormap import cmbcmap
import math
#################################################
# usage :python3 waveFullSoln instance Lmax 
#        python3 waveFullSoln 1 1000 
#
# need to use formula (3.4) in the wave paper
tau = 4*1e-2 
#kappa1= 2.3 
kappa1= 4.1 
kappa2= 4.5
Lmax = 1500   # Truncated the exact series at large Degree L_tilde up to 1500

map_type = 'Full_soln'
inst_num = int(sys.argv[1]) # instance number from command line
Lmax = int(sys.argv[2]) # Lmax  from command line

tt = 10*tau
#tt = 0.0
#tt = tau

def AA(L): # Angular power spectrum of the random noise W
      if (L>0):
         value = L**(-kappa2)
      else:
         value = 1.0
      return value
def CC(L): # Angular power spectrum of the random field
      if (L>0):
         value2 = L**(-kappa1)
      else:
         value2 = 1.0
      return value2

def M(L): 
    if (L> kap):
        return 1j * math.sqrt(omg**(-2)*L*(L+1) - 1)
    else:
        return math.sqrt(1 - omg**(-2)*L*(L+1))

def zlmin(L):
           vv= 0.5*c**2*gam**(-1)*(1-M(L))
           return vv
def zlplus(L):
           vv4= 0.5*c**2*gam**(-1)*(1+M(L))
           return vv4

#
alpha = 0.9 
total = 0.0
Nside = 2048
sig0 = 10
ep=2.220446049250313e-16
c=1
gam=1
#kk= 0.1
kk = 0.05
omg=c/(2*gam*kk)
kap=0.5*(math.sqrt(1+4*omg**2)-1)

# read in the coefficients of the initial random field
ld_dir = './'
# The initial random field was generated by ....
#ld_alm = ld_dir + 'FracPDE_Nside2048_instance1' + 'kap2p3.mat' # with kappa1 = 2.3 
ld_alm = ld_dir + 'FracPDE_Nside2048_instance1' + 'kap4p1.mat' # with kappa1 = 4.1
mat_alm = sio.loadmat(ld_alm)
RF_LMAX = 1500
alm = np.reshape(mat_alm['alm'],[hp.Alm.getsize(RF_LMAX)])
Vlm = np.zeros( alm.shape, dtype=complex)       # inhomogeneous soln 
Vlm_full = np.zeros( alm.shape, dtype=complex)  # full solution
#np.random.seed(2022)
for Lm in range(0,Lmax+1):
   Vm = np.zeros((Lm+1),dtype=complex)         # inhom soln
   Vm_full = np.zeros((Lm+1),dtype=complex)    # full soln
   lam = Lm*(Lm+1)
   
   def sigma(L):
       E1 = lambda r: Eab(a=alpha,b=alpha,ep=ep,zeta=0.95, z = -zlmin(L)*r**alpha)
       E2 = lambda r: Eab(a=alpha,b=alpha,ep=ep,zeta=0.95, z = -zlplus(L)*r**alpha)
       tmp = integrate.quad(lambda r: r**(2*alpha-2)*(np.abs(E1(r)-E2(r)))**2, 0, tt-tau, epsabs=1e-10) 
       return tmp*gam**2/ (np.abs(M(L)))**2
   if (tt>tau):
      scale = np.sqrt(sigma(Lm)[0]) 
      I0 = np.random.normal(0, scale)
      I1 = np.random.normal(0, scale, size=Lm)
      I2 = np.random.normal(0, scale, size=Lm)
   else:
      I0 = 0.
      I1 = np.zeros(Lm)
      I2 = np.zeros(Lm)
 
   Vm[0] = sig0*np.sqrt(AA(Lm))*I0  # V_{Lm,0}
   Vm[1:] = sig0*np.sqrt(AA(Lm)/2)*(I1 - complex(0,1)*I2)
   # get the coefficients from the random field
   Z_lm = np.zeros(Lm+1,dtype=complex)
   for m in range(0,Lm+1):
        idxlm  = hp.Alm.getidx(RF_LMAX,Lm,m)
        Z_lm[m]= alm[idxlm]
   
   # compute the homogeneous soln part
   #bZ = MLvalZ.item()*Z_lm
   F1_ell_al = 0.5*(Eab(a=alpha,b=1.0,ep=ep,zeta=0.95,z=-zlmin(Lm)*tt**alpha))
   F1_ell_al = F1_ell_al + 0.5*(Eab(a=alpha,b=1.0,ep=ep,zeta=0.95,z=-zlplus(Lm)*tt**alpha))
   F2_ell_al = 0.5*(Eab(a=alpha,b=1.0,ep=ep,zeta=0.95,z=-zlmin(Lm)*tt**alpha))
   F2_ell_al = F2_ell_al - 0.5*(Eab(a=alpha,b=1.0,ep=ep,zeta=0.95,z=-zlplus(Lm)*tt**alpha))
   F2_ell_al = F2_ell_al/ M(Lm)
   Fell_al = F1_ell_al + F2_ell_al
   bZn = Fell_al*Z_lm

   #print(Lm, bZ.shape, I0.shape, I1.shape, I2.shape)
   Vm_full = bZn + Vm

   for m in range(0,Lm+1):
        idxlm  = hp.Alm.getidx(RF_LMAX,Lm,m)
        Vlm[idxlm] = Vm[m]
        Vlm_full[idxlm] = Vm_full[m]

# saving the coefficients for later plots
map_type = 'Inhom_soln'
#sv = map_type + '_Lmax' + str(Lmax) + '_t_10tau_tau0p04_alpha0p9_kap1_2p3_kap2_2p5.mat'
#sv = map_type + '_Lmax' + str(Lmax) + '_t_10tau_tau0p04_alpha0p9_kap1_4p1_kap2_2p5.mat'
sv = map_type + '_Lmax' + str(Lmax) + '_t_10tau_tau0p04_alpha0p9_kap1_4p1_kap2_4p5.mat'
sio.savemat(sv, mdict={'Vlm':Vlm})

randfield = hp.alm2map(alms=Vlm,nside=Nside)   
print('min/max val=',min(randfield), max(randfield))
#sv_fig = map_type + '_Lmax' + str(Lmax) + '_t_10tau_tau0p04_alpha0p9_kap1_2p3_kap2_2p5.png'
#sv_fig = map_type + '_Lmax' + str(Lmax) + '_t_10tau_tau0p04_alpha0p9_kap1_4p1_kap2_2p5.png'
sv_fig = map_type + '_Lmax' + str(Lmax) + '_t_10tau_tau0p04_alpha0p9_kap1_4p1_kap2_4p5.png'
plt.figure(1)
cm = cmbcmap()
ti =r'Inhomogeneous solution $u_L(t)$ at $t=10\tau$, with ${\tau}=4\cdot 10^{-2}$ ' + ', $L= %d$' %Lmax
hp.mollview(randfield, title = ti, cmap=cm, min=-10, max=10, xsize=1200, nest=False)
plt.title(ti)
plt.savefig(sv_fig,format='png',dpi=600)

# saving coefficients
map_type = 'Full_soln'
#sv = map_type + '_Lmax' + str(Lmax) + '_t_10tau_tau0p04_alpha0p9_kap1_2p3_kap2_2p5.mat'
#sv = map_type + '_Lmax' + str(Lmax) + '_t_10tau_tau0p04_alpha0p9_kap1_4p1_kap2_2p5.mat'
sv = map_type + '_Lmax' + str(Lmax) + '_t_10tau_tau0p04_alpha0p9_kap1_4p1_kap2_4p5.mat'
sio.savemat(sv, mdict={'Vlm':Vlm_full})

# plotting full solution
full_randfield = hp.alm2map(alms=Vlm_full,nside=Nside)   
print('min/max val=',min(full_randfield), max(full_randfield))
#sv_fig = map_type + '_Lmax' + str(Lmax) + '_t_10tau_tau0p04_alpha0p9_kap1_2p3_kap2_2p5.png'
#sv_fig = map_type + '_Lmax' + str(Lmax) + '_t_10tau_tau0p04_alpha0p9_kap1_4p1_kap2_2p5.png'
sv_fig = map_type + '_Lmax' + str(Lmax) + '_t_10tau_tau0p04_alpha0p9_kap1_4p1_kap2_4p5.png'
plt.figure(2)
cm = cmbcmap()
ti =r'Full solution $u_L(t)$ at $t=10\tau$, with ${\tau}=4\cdot 10^{-2}$ ' + ', $L= %d$' %Lmax
hp.mollview(full_randfield, title = ti, cmap=cm, min=-10, max=10, xsize=1200, nest=False)
plt.title(ti)
plt.savefig(sv_fig,format='png',dpi=600)

